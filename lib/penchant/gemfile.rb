require 'erb'

module Penchant
  class Gemfile
    attr_reader :path, :is_deployment

    def self.do_full_env_switch!(env, deployment = false)
      return false if !(gemfile = pre_switch(env, deployment))

      gemfile.switch_to!(env, deployment)
    end

    def self.switch_back!(fallback_env)
      return false if !(gemfile = pre_switch(fallback_env))

      gemfile.switch_back!(fallback_env)
    end

    def self.pre_switch(env, deployment = false)
      gemfile = Penchant::Gemfile.new
      return false if !gemfile.has_processable_gemfile?
      gemfile.run_dot_penchant!(env, deployment)

      gemfile
    end

    def current_env ; @env ; end

    def initialize(path = Dir.pwd)
      @path = path
    end

    def gemfile_path
      file_in_path('Gemfile')
    end

    def has_gemfile?
      File.file?(gemfile_path)
    end

    def has_dot_penchant?
      File.file?('.penchant')
    end

    def gemfile_erb_path
      file_in_path('Gemfile.erb')
    end

    def gemfile_penchant_path
      file_in_path('Gemfile.penchant')
    end

    def has_gemfile_erb?
      File.file?(gemfile_erb_path)
    end

    def has_gemfile_penchant?
      File.file?(gemfile_penchant_path)
    end

    def has_processable_gemfile?
      has_gemfile_erb? || has_gemfile_penchant?
    end

    def processable_gemfile_path
      has_gemfile_erb? ? gemfile_erb_path : gemfile_penchant_path
    end

    def environment
      gemfile_header.strip[%r{environment: ([^, ]*)}, 1]
    end

    def deployment?
      gemfile_header['deployment mode'] != nil
    end

    class ERBFile
    end

    class PenchantFile
      def self.result(data, *args)
        new(data).result(*args)
      end

      def initialize(data)
        @data = data
      end

      attr_reader :environment, :is_deployment

      def result(_env, _is_deployment)
        @environment = _env.to_s.to_sym
        @is_deployment = _is_deployment

        @output = []

        instance_eval(@data)

        @output.join("\n")
      end

      def gem(*args)
        @output << %{gem #{args_to_string(args)}}
      end

      def gems(*gems)
        template = {}

        while gems.last.instance_of?(Hash)
          template.merge!(gems.pop)
        end

        gems.flatten.each do |gem_name|
          options = Hash[
            template.collect { |key, value|
              value = value % gem_name if value.respond_to?(:%)

              [ key, value ]
            }.sort
          ]

          args = [ gem_name ]
          args << options if !options.empty?

          gem *args
        end
      end

      def group(*args, &block)
        @output << ""
        @output << %{group #{args_to_string(args)} do}

        call_and_indent_output(block)

        @output << %{end}
      end

      def source(*args)
        @output << %{source #{args_to_string(args)}}
      end

      def env(*args)
        yield if args.include?(environment)
      end

      def no_deployment
        yield if !is_deployment
      end

      private
      def args_to_string(args)
        args.inspect[1..-2]
      end

      def call_and_indent_output(block)
        index = @output.length
        block.call
        index.upto(@output.length - 1) do |i|
          @output[i] = "  " + @output[i]
        end
      end
    end

    def switch_to!(gemfile_env = nil, deployment = false)
      @env, @is_deployment = gemfile_env, deployment

      output = [ header, process(template) ]

      File.open(gemfile_path, 'wb') { |fh| fh.print output.join("\n") }
    end

    def run_dot_penchant!(env, deployment)
      DotPenchant.run(env || environment, deployment) if has_dot_penchant?
    end

    def header
      header = [ "# generated by penchant, environment: #{current_env}" ]

      if is_deployment
        header << ", deployment mode (was #{environment})"
      end

      header.join
    end

    def prior_environment
      gemfile_header[%r{\(was (.+)\)}, 1]
    end

    def switch_back!(fallback_env)
      switch_to!(prior_environment || fallback_env)
    end

    private
    def file_in_path(file)
      File.join(@path, file)
    end

    def process(template)
      case File.extname(processable_gemfile_path)
      when '.penchant'
        PenchantFile.result(template, @env, @is_deployment)
      when '.erb'
        ERB.new(template, nil, nil, '@_erbout').result(binding).lines.to_a
      end
    end

    def template
      File.read(processable_gemfile_path)
    end

    def env(check, template = {}, &block)
      if check.to_s == @env.to_s
        original_erbout = @_erbout.dup

        output = instance_eval(&block).lines.to_a

        output.each do |line|
          if gem_name = line[%r{gem ['"]([^'"]+)['"]}, 1]
            line.replace(line.rstrip + options_to_string(gem_name, template) + "\n")
          end
        end

        @_erbout = original_erbout + output.join
      end
    end

    def with_gem_list(*gems)
      template = {}
      template = gems.pop if gems.last.instance_of?(Hash)

      gems.flatten.each do |gem|
        @_current_gem = gem
        if block_given?
          yield
        else
          @_erbout += gem(template) + "\n"
        end
      end
    end

    alias :gems :with_gem_list

    def gem(template = {})
      "gem '#{@_current_gem}'" + options_to_string(@_current_gem, template)
    end

    def options_to_string(gem_name, template = {})
      template.collect do |key, value|
        ", #{key.inspect} => %{#{value % gem_name}}"
      end.join
    end

    def no_deployment(&block)
      instance_eval(&block) if !@is_deployment
    end

    def gemfile_header
      (has_gemfile? and File.readlines(gemfile_path).first) or ""
    end
  end
end

